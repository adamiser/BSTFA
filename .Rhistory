plot.title = paste0(toupper(substring(type,1,1)), substring(type,2))
}
if (type=='median') {
predloc$predm <- apply(pred, 1, median)
plot.title = paste0(toupper(substring(type,1,1)), substring(type,2))
}
if (type=='lb') {
predloc$predm <- apply(pred, 1, quantile, prob=ci.level[1])
plot.title = paste0((ci.level[2] - ci.level[1])*100, "% Lower Bound")
}
if (type=='ub') {
predloc$predm <- apply(pred, 1, quantile, prob=ci.level[2])
plot.title = paste0((ci.level[2] - ci.level[1])*100, "% Upper Bound")
}
if (!with.uncertainty) {
max_value = max(abs(min(predloc$predm)),abs(max(predloc$predm)))
min_value = -max_value
}
if (with.uncertainty) {
predloc$predl <- apply(pred, 1, quantile, prob=ci.level[1])
predloc$predu <- apply(pred, 1, quantile, prob=ci.level[2])
max_value = max(abs(min(predloc$predl)),abs(max(predloc$predl)), abs(min(predloc$predu)),abs(max(predloc$predu)))
min_value = -max_value
}
if (!map) {
m <- ggplot2::ggplot(aes(x=Lon, y=Lat), data=predloc) +
geom_point(aes(x=Lon, y=Lat, color=predm)) +
scale_colour_gradientn(colours=color.gradient, name=legend.name,
limits = c(min_value, max_value)) +
ggtitle(plot.title) + xlab("Longitude") + ylab("Latitude")
# geom_point(data=out$knots[[1]], aes(x=x,y=y)) +
# geom_point(x=out$coords[out$factors.fixed[loading],1], y=out$coords[out$factors.fixed[loading],2], color='green')
if (!with.uncertainty) print(m)
if (with.uncertainty) {
l <- ggplot(data=predloc) +
geom_point(aes(x=Lon, y=Lat, color=predl)) +
scale_colour_gradientn(colours=color.gradient, name=legend.name,
limits = c(min_value, max_value)) +
ggtitle(paste0((ci.level[2]-ci.level[1])*100,'% Lower Bound')) + xlab("Longitude") + ylab("Latitude")
u <- ggplot(data=predloc) +
geom_point(aes(x=Lon, y=Lat, color=predu)) +
scale_colour_gradientn(colours=color.gradient, name=legend.name,
limits = c(min_value, max_value)) +
ggtitle(paste0((ci.level[2]-ci.level[1])*100,'% Upper Bound')) + xlab("Longitude") + ylab("Latitude")
print(ggpubr::ggarrange(l, m, u, nrow=1, common.legend=T, legend="right"))
}
}
if (map) {
sf_polygon <- sf::st_sfc(sf::st_polygon(list(as.matrix(map_data_loc[,c(1,2)]))), crs=4326)
### Check if points fall inside of polygon ###
inside = c()
for (kk in 1:nrow(predloc)) {
point = sf::st_sfc(sf::st_point(as.matrix(predloc[kk,c(1,2)])), crs=4326)
if (sf::st_intersects(point, sf_polygon, sparse=FALSE)) inside = append(inside, kk)
}
predloc.inside = predloc[inside, ]
m = ggplot() +
## First layer: worldwide map
geom_polygon(data = full_map,
aes(x=long, y=lat, group = group),
color = '#9c9c9c', fill = '#f3f3f3') +
## Second layer: Country map
geom_polygon(data = map_data_loc,
aes(x=long, y=lat, group = group),
color = 'red', fill='gray') +
coord_map() +
coord_fixed(1.3,
xlim = c(min(out$coords[,1])-1, max(out$coords[,1])+1),
ylim = c(min(out$coords[,2])-1, max(out$coords[,2])+1)) +
ggtitle("Slope") + # FIX ME #
theme(panel.background =element_rect(fill = 'blue')) +
geom_point(data=predloc.inside, aes(x=Lon, y=Lat, color=predm)) +
scale_colour_gradientn(colours=color.gradient, name=legend.name,
limits = c(min_value, max_value)) +  # FIX ME #
xlab('Longitude') +
ylab('Latitude')
print(m)
if (with.uncertainty) {
l = ggplot() +
## First layer: worldwide map
geom_polygon(data = full_map,
aes(x=long, y=lat, group = group),
color = '#9c9c9c', fill = '#f3f3f3') +
## Second layer: Country map
geom_polygon(data = map_data_loc,
aes(x=long, y=lat, group = group),
color = 'red', fill='gray') +
coord_map() +
coord_fixed(1.3,
xlim = c(min(out$coords[,1])-1, max(out$coords[,1])+1),
ylim = c(min(out$coords[,2])-1, max(out$coords[,2])+1)) +
ggtitle(paste0((ci.level[2]-ci.level[1])*100,'% Lower Bound')) +
theme(panel.background =element_rect(fill = 'blue')) +
geom_point(data=predloc.inside, aes(x=Lon, y=Lat, color=predl)) +
scale_colour_gradientn(colours=color.gradient, name=legend.name,
limits = c(min_value, max_value)) +
xlab('Longitude') +
ylab('Latitude')
u = ggplot() +
## First layer: worldwide map
geom_polygon(data = full_map,
aes(x=long, y=lat, group = group),
color = '#9c9c9c', fill = '#f3f3f3') +
## Second layer: Country map
geom_polygon(data = map_data_loc,
aes(x=long, y=lat, group = group),
color = 'red', fill='gray') +
coord_map() +
coord_fixed(1.3,
xlim = c(min(out$coords[,1])-1, max(out$coords[,1])+1),
ylim = c(min(out$coords[,2])-1, max(out$coords[,2])+1)) +
ggtitle(paste0((ci.level[2]-ci.level[1])*100,'% Upper Bound')) +
theme(panel.background =element_rect(fill = 'blue')) +
geom_point(data=predloc.inside, aes(x=Lon, y=Lat, color=predu)) +
scale_colour_gradientn(colours=color.gradient, name=legend.name,
limits = c(min_value, max_value)) +
xlab('Longitude') +
ylab('Latitude')
print(ggpubr::ggarrange(l, m, u, nrow=1, common.legend=T, legend="right"))
}
}
}
#' Plot the factors
#' @param out output from STFA or STFAfull
#' @export plot.factor
plot.factor = function(out, factor=1, together=FALSE, include.legend=TRUE,
type='mean', ci.level=c(0.025, 0.975)) {
par(mfrow=c(1,1))
if (type=='mean') PFmat = matrix(apply(out$PFmat,2,mean),nrow=out$n.times,ncol=out$n.factors,byrow=FALSE)
if (type=='median') PFmat = matrix(apply(out$PFmat,2,median),nrow=out$n.times,ncol=out$n.factors,byrow=FALSE)
if (type=='lb') PFmat = matrix(apply(out$PFmat,2,quantile,prob=ci.level[1]),nrow=out$n.times,ncol=out$n.factors,byrow=FALSE)
if (type=='ub') PFmat = matrix(apply(out$PFmat,2,quantile,prob=ci.level[1]),nrow=out$n.times,ncol=out$n.factors,byrow=FALSE)
if (together) {
plot(y=PFmat[,1], x=out$dates, type='l', main = ('All Factors'),
xlab = 'Time', ylab='Value', col=1,
#ylim=range(PFmat))
ylim=c(-7,7)) # FIX ME
for (i in 2:out$n.factors) {
lines(y=PFmat[,i], x=out$dates, type='l', col=i)
}
if (include.legend) {
legend("topleft", legend=paste("Factor", seq(1,out$n.factors)), col = seq(1,out$n.factors), lty=1)
}
}
if (!together) {
for (i in factor) {
plot(y=PFmat[,i], x=out$dates, type='l', main=paste('Factor', i),
xlab = 'Time', ylab='Value')
}
}
}
#' Plot annual curve
#' @param out output from STFA or STFAfull
#' @importFrom mgcv cSplineDes
#' @export plot.annual
plot.annual <- function(out, location, add=F,
years="one",
interval=0.95, yrange=NULL,
new_x=NULL){
y = out$y
x_set = out$doy
if(years=="all"){
dates.pred <- seq(as.Date(out$dates[1]), as.Date(out$dates[length(out$dates)]), by=1)
doy.pred <- as.numeric(strftime(dates.pred, format="%j"))
}else{
dates.pred <- seq(as.Date("2001-01-01"), as.Date("2001-12-31"), by=1) # 2001 doesn't matter; just gets correct doy
doy.pred <- as.numeric(strftime(dates.pred, format="%j"))
months.plot <- seq(as.Date("2001-01-01"), as.Date("2001-12-31"), by="month") # 2001 doesn't matter; just gets correct month
at.doy.plot <- as.numeric(strftime(months.plot, format="%j"))
months.plot <- months(months.plot, abbreviate=T)
}
knots <- seq(1, 366, length=out$n.seasn.knots+1)
bs.basis <- mgcv::cSplineDes(doy.pred, knots)
if(length(location)==1){
loc.seq <- ((location-1)*out$n.seasn.knots + 1):(location*out$n.seasn.knots)
xi.pred <- out$xi[,loc.seq]
ann.pred <- bs.basis%*%t(xi.pred)
ann.pred.mean <- apply(ann.pred, 1, mean)
if(interval>0){
ann.pred.bounds <- apply(ann.pred, 1, quantile, probs=c((1-interval)/2, (1+interval)/2))
}else{
ann.pred.bounds <- NULL
}
if(add==T){
lines(dates.pred, ann.pred.mean, lwd=1.5)
if(interval>0){
polygon(c(dates.pred, rev(dates.pred)), c(ann.pred.bounds[1,], rev(ann.pred.bounds[2,])), col=rgb(.5, .5, .5, .4), border=NA)
}
lines(dates.pred, ann.pred.mean, lwd=2)
}else{ #end if add==T
if(length(y)>0){
y.this <- out$y[((location-1)*out$n.times +1):(location*out$n.times)]
}else{
y.this <- NULL
}
if(is.null(yrange)==T){
ylims <- range(c(ann.pred.mean, ann.pred.bounds, y.this), na.rm=T)
}else{
ylims <- yrange
}
if(years=="all"){
plot(dates.pred, ann.pred.mean, lwd=1.5, type='l', xlab="Date", ylab="Annual Seasonal Cycle", ylim=ylims, main=paste("Location", location))
}else{
plot(doy.pred, ann.pred.mean, lwd=1.5, type='l', xaxt="n", xlab="Date", ylab="Annual Seasonal Cycle", ylim=ylims)
axis(1, at=at.doy.plot, labels=months.plot)
}
if(interval>0){
if(years=="all"){
polygon(c(dates.pred, rev(dates.pred)), c(ann.pred.bounds[1,], rev(ann.pred.bounds[2,])), col=rgb(.5, .5, .5, .4), border=NA)
lines(dates.pred, ann.pred.mean, lwd=1.5)
}else{
polygon(c(doy.pred, rev(doy.pred)), c(ann.pred.bounds[1,], rev(ann.pred.bounds[2,])), col=rgb(.5, .5, .5, .4), border=NA)
lines(doy.pred, ann.pred.mean, lwd=1.5)
}
}
if(length(y)>0){
if(years=="all"){
dates.data <- as.Date(out$dates)
points(dates.data, y.this, col=rgb(.5, .5, .5, .25))
}else{
points(x_set, y.this, col=rgb(.5, .5, .5,.25))
}
}
}
} else { # New location
if (out$spatial.style=='grid') {
# predS=makePredS(out,location)
predS <- NULL
for(kk in 1:length(out$knots.spatial)) {
bspred <- bisquare2d(as.matrix(location), as.matrix(out$knots.spatial[[kk]]))
predS <- cbind(predS, bspred)
}
}
if (out$spatial.style == 'fourier') {
m.fft.lon <- sapply(1:(out$n.spatial.bases/2), function(k) {
sin_term <- sin(2 * pi * k * (location[,1])/out$freq.lon)
cos_term <- cos(2 * pi * k * (location[,1])/out$freq.lon)
cbind(sin_term, cos_term)
})
m.fft.lat <- sapply(1:(out$n.spatial.bases/2), function(k) {
sin_term <- sin(2 * pi * k * (location[,2])/out$freq.lat)
cos_term <- cos(2 * pi * k * (location[,2])/out$freq.lat)
cbind(sin_term, cos_term)
})
Slon <- cbind(m.fft.lon[1:nrow(location),], m.fft.lon[(nrow(location)+1):(2*nrow(location)),])
Slat <- cbind(m.fft.lat[1:nrow(location),], m.fft.lat[(nrow(location)+1):(2*nrow(location)),])
predS = matrix(Slat*Slon,ncol=out$n.spatial.bases)
}
if (out$spatial.style == 'tps') {
coords_added = rbind(out$coords,location)
predS = matrix(npreg::basis.tps(coords_added, knots=out$knots.spatial, rk=TRUE)[-(1:nrow(out$coords)),-(1:2)],ncol=out$n.spatial.bases)
}
if (!is.null(new_x)) {
predS <- cbind(predS, new_x)
predloc <- predloc[complete.cases(predS),]
predS <- predS[complete.cases(predS),]
}
predS.xi = as(kronecker(predS, diag(out$n.seasn.knots)), "sparseMatrix")
ximean <- predS.xi%*%t(out$alpha.xi)
xiresid <- matrix(rnorm(nrow(location)*out$n.seasn.knots*out$draws,
mean=rep(0,nrow(location)*out$n.seasn.knots*out$draws),
sd=sqrt(rep(c(out$tau2.xi),each=nrow(location)*out$n.seasn.knots))),ncol=out$draws,byrow=TRUE)
# xi.pred <- ximean + xiresid
xi.pred <- ximean
ann.pred <- bs.basis%*%xi.pred
ann.pred.mean <- apply(ann.pred, 1, mean)
if(interval>0){
ann.pred.bounds <- apply(ann.pred, 1, quantile, probs=c((1-interval)/2, (1+interval)/2))
}else{
ann.pred.bounds <- NULL
}
if(is.null(yrange)==T){
ylims <- range(c(ann.pred.mean, ann.pred.bounds), na.rm=T)
}else{
ylims <- yrange
}
if(years=="all"){
plot(dates.pred, ann.pred.mean, lwd=1.5, type='l', xlab="Date", ylab="Annual Seasonal Cycle", ylim=ylims, main=paste("Location", location[1], location[2]))
}else{
plot(doy.pred, ann.pred.mean, lwd=1.5, type='l', xaxt="n", xlab="Date", ylab="Annual Seasonal Cycle", ylim=ylims)
axis(1, at=at.doy.plot, labels=months.plot)
}
if(interval>0){
if(years=="all"){
polygon(c(dates.pred, rev(dates.pred)), c(ann.pred.bounds[1,], rev(ann.pred.bounds[2,])), col=rgb(.5, .5, .5, .4), border=NA)
lines(dates.pred, ann.pred.mean, lwd=1.5)
}else{
polygon(c(doy.pred, rev(doy.pred)), c(ann.pred.bounds[1,], rev(ann.pred.bounds[2,])), col=rgb(.5, .5, .5, .4), border=NA)
lines(doy.pred, ann.pred.mean, lwd=1.5)
}
}
}
}
?predictSTFA
ttt = matrix('Longitude' = -111.96, 'Latitude' = 41.06)
ttt = matrix(c(-111.96,41.06),nrow=1)
ttt
colnames(ttt) = c('Longitude', 'Latitude')
ttt
plot.location(out, location=ttt,
uncertainty=TRUE, xrange=c('1959-01-01', '1979-01-01'))
# par(mfrow=c(1,1))
# plot.location(out,1,xrange=c('1969-01-01', '1979-01-01'),truth = TRUE)
# devtools::load_all()
#
# preds1 = predictSTFA(out,location=1,type='ub')
#
# preds2 = predictSTFA(out,location=1,type='ub')
#
#
#
plot.location(out, location=data.frame('Longitude' = -111.96, 'Latitude' = 41.06),
uncertainty=TRUE, xrange=c('1959-01-01', '1979-01-01'))
plot.location(out, location=ttt,
uncertainty=TRUE, xrange=c('1959-01-01', '1979-01-01'))
# plot.factor(out, together=TRUE)
#
# plot.trace(out, parameter='beta', param.range=1:5)
#
# plot.annual(out,location=10)
#
# devtools::load_all()
# plot.map(out,parameter='slope',location='utah',state=TRUE,map=TRUE,
#          with.uncertainty = FALSE)
#
predictSTFA(out,location=data.frame('Longitude' = -111.96, 'Latitude' = 41.06),type='all')
# plot.factor(out, together=TRUE)
#
# plot.trace(out, parameter='beta', param.range=1:5)
#
# plot.annual(out,location=10)
#
# devtools::load_all()
# plot.map(out,parameter='slope',location='utah',state=TRUE,map=TRUE,
#          with.uncertainty = FALSE)
#
predictSTFA(out,location=data.frame('Longitude' = -111.96, 'Latitude' = 41.06),type='mean')
pi
devtools::load_all()
devtools::load_all()
predictBSTFA()
devtools::load_all()
out = STFA(iters=100,ymat=utahDataList$TemperatureVals,
dates=utahDataList$Dates,
coords=as.matrix(utahDataList$Coords),
factors.fixed = c(144,89,129,78), n.seasn.knots=7,
spatial.style='fourier', load.style='fourier',
n.load.bases = 8, n.spatial.bases = 12, n.temp.bases=126,
verbose=FALSE, plot.factors=FALSE)
# devtools::load_all()
#
out = BSTFA(iters=100,ymat=utahDataList$TemperatureVals,
dates=utahDataList$Dates,
coords=as.matrix(utahDataList$Coords),
factors.fixed = c(144,89,129,78), n.seasn.knots=7,
spatial.style='fourier', load.style='fourier',
n.load.bases = 8, n.spatial.bases = 12, n.temp.bases=126,
verbose=FALSE, plot.factors=FALSE)
# plot.factor(out, together=TRUE)
#
# plot.trace(out, parameter='beta', param.range=1:5)
#
# plot.annual(out,location=10)
#
# devtools::load_all()
# plot.map(out,parameter='slope',location='utah',state=TRUE,map=TRUE,
#          with.uncertainty = FALSE)
#
predictBSTFA(out,location=data.frame('Longitude' = -111.96, 'Latitude' = 41.06),type='mean')
plot.location(out,location=10,truth=TRUE)
#
# out = BSTFA(iters=100,ymat=utahDataList$TemperatureVals,
#            dates=utahDataList$Dates,
#            coords=as.matrix(utahDataList$Coords),
#            factors.fixed = c(144,89,129,78), n.seasn.knots=7,
#            spatial.style='fourier', load.style='fourier',
#            n.load.bases = 8, n.spatial.bases = 12, n.temp.bases=126,
#            verbose=FALSE, plot.factors=FALSE)
#
# par(mfrow=c(1,1))
plot.location(out,1,xrange=c('1969-01-01', '1979-01-01'),truth = TRUE)
#
# out = BSTFA(iters=100,ymat=utahDataList$TemperatureVals,
#            dates=utahDataList$Dates,
#            coords=as.matrix(utahDataList$Coords),
#            factors.fixed = c(144,89,129,78), n.seasn.knots=7,
#            spatial.style='fourier', load.style='fourier',
#            n.load.bases = 8, n.spatial.bases = 12, n.temp.bases=126,
#            verbose=FALSE, plot.factors=FALSE)
#
# par(mfrow=c(1,1))
plot.location(out,1,xrange=c('1969-01-01', '1979-01-01'),truth = TRUE,pred.int=FALSE)
devtools::load_all()
#
# out = BSTFA(iters=100,ymat=utahDataList$TemperatureVals,
#            dates=utahDataList$Dates,
#            coords=as.matrix(utahDataList$Coords),
#            factors.fixed = c(144,89,129,78), n.seasn.knots=7,
#            spatial.style='fourier', load.style='fourier',
#            n.load.bases = 8, n.spatial.bases = 12, n.temp.bases=126,
#            verbose=FALSE, plot.factors=FALSE)
#
# par(mfrow=c(1,1))
plot.location(out,1,xrange=c('1969-01-01', '1979-01-01'),truth = TRUE,pred.int=FALSE)
#
# out = BSTFA(iters=100,ymat=utahDataList$TemperatureVals,
#            dates=utahDataList$Dates,
#            coords=as.matrix(utahDataList$Coords),
#            factors.fixed = c(144,89,129,78), n.seasn.knots=7,
#            spatial.style='fourier', load.style='fourier',
#            n.load.bases = 8, n.spatial.bases = 12, n.temp.bases=126,
#            verbose=FALSE, plot.factors=FALSE)
#
# par(mfrow=c(1,1))
plot.location(out,1,xrange=c('1969-01-01', '1979-01-01'),truth = TRUE,pred.int=TRUE)
# devtools::load_all()
#
# preds1 = predictSTFA(out,location=1,type='ub')
#
# preds2 = predictSTFA(out,location=1,type='ub')
#
#
#
plot.location(out, location=data.frame('Longitude' = -111.96, 'Latitude' = 41.06),
uncertainty=TRUE, xrange=c('1959-01-01', '1979-01-01'))
# devtools::load_all()
#
# preds1 = predictSTFA(out,location=1,type='ub')
#
# preds2 = predictSTFA(out,location=1,type='ub')
#
#
#
plot.location(out, location=data.frame('Longitude' = -111.96, 'Latitude' = 41.06),
uncertainty=TRUE, xrange=c('1959-01-01', '1979-01-01'), pred.int=FALSE)
# devtools::load_all()
#
# preds1 = predictSTFA(out,location=1,type='ub')
#
# preds2 = predictSTFA(out,location=1,type='ub')
#
#
#
plot.location(out, location=data.frame('Longitude' = -111.96, 'Latitude' = 41.06),
uncertainty=TRUE, xrange=c('1959-01-01', '1979-01-01'), pred.int=TRUE)
window=1050:1090
plot(y=utahDataList$TemperatureVals[window,which(utahDataList$Locations=='MOAB')],
x=utahDataList$Dates[window], type = 'l',
main = "Moab",
xlab = "",
ylab = "",
ylim=c(-18,23),
cex.main=1.5)
data <- data.frame(
Argument = c("plot.location", "plot.annual", "plot.grid", "plot.map", "plot.factor"),
Description = c("",
"",
"",
"",
"")
)
knitr::kable(data, caption = "Table of Plotting/Visualization Functions")
data <- data.frame(
Function = c("plot.location", "plot.annual", "plot.grid", "plot.map", "plot.factor"),
Description = c("",
"",
"",
"",
""),
'Required Arguments' = c("",
"",
"",
"",
"")
)
knitr::kable(data, caption = "Table of Plotting/Visualization Functions")
data <- data.frame(
Function = c("plot.location", "plot.annual", "plot.grid", "plot.map", "plot.factor"),
Description = c("",
"",
"",
"",
"")
)
knitr::kable(data, caption = "Table of Plotting/Visualization Functions")
?as.sparse
??as.sparse
?as
n.locs=50
n.times=100
Tsub <- -(n.times/2-0.5):(n.times/2-0.5)
Tfull <- kronecker(Matrix::Diagonal(n=n.locs), Tsub)
ItTT <- as(kronecker(diag(1,n.locs), t(Tsub)%*%Tsub), "sparseMatrix")
typeof(ItTT)
class(ItTT)
library(knitr)
devtools::load_all()
# library(BSTFA)
n.times=100
n.locs=50
Tsub <- -(n.times/2-0.5):(n.times/2-0.5)
Tsub
Tfull <- kronecker(Matrix::Diagonal(n=n.locs), Tsub)
dim(Tfull)
n.times=100
n.locs=50
Tsub <- -(n.times/2-0.5):(n.times/2-0.5)
Tfull <- kronecker(Matrix::Diagonal(n=n.locs), Tsub)
ItTT <- as(kronecker(Matrix::Diagonal(n=n.locs), t(Tsub)%*%Tsub), "sparseMatrix")
?Matrix::Diagonal
class(Matrix::Diagonal(n=50))
?matrixcalc::vec
